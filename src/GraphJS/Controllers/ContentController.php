<?php

/*
 * This file is part of the Pho package.
 *
 * (c) Emre Sokullu <emre@phonetworks.org>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

 namespace GraphJS\Controllers;

use CapMousse\ReactRestify\Http\Request;
use CapMousse\ReactRestify\Http\Response;
use CapMousse\ReactRestify\Http\Session;
use Pho\Kernel\Kernel;
use PhoNetworksAutogenerated\User;
use PhoNetworksAutogenerated\Page;
use PhoNetworksAutogenerated\Blog;
use PhoNetworksAutogenerated\UserOut\Star;
use PhoNetworksAutogenerated\UserOut\Comment;
use Pho\Lib\Graph\ID;


/**
 * Takes care of Content
 * 
 * @author Emre Sokullu <emre@phonetworks.org>
 */
class ContentController extends AbstractController
{
    /**
     * Star 
     * 
     * [url]
     * 
     * @param Request  $request
     * @param Response $response
     * @param Session  $session
     * @param Kernel   $kernel
     * @param string   $id
     * 
     * @return void
     */
    public function star(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'url' => 'required|url',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Url required.");
            return;
        }
        $i = $kernel->gs()->node($id);  
        $page = $this->_fromUrlToNode($kernel, $data["url"]);
        $i->star($page);    
        $this->succeed(
            $response, [
            "count" => count($page->getStarrers())
            ]
        );
    }
 
    protected function _fromUrlToNode(Kernel $kernel, string $url) 
    {
        $get_title = function(string $url): string 
        { // via https://stackoverflow.com/questions/4348912/get-title-of-website-via-link
            if(!function_exists("curl_init")) {
                $str = file_get_contents($url);
            }
            else {
                $ch =  curl_init($url);
                curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
                curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
                $str = curl_exec($ch);
            }
            if(strlen($str)>0){
              $str = trim(preg_replace('/\s+/', ' ', $str)); // supports line breaks inside <title>
              preg_match("/\<title\>(.*?)\<\/title\>/i",$str,$title); // ignore case
              return html_entity_decode($title[1]);
            }
            return "-";
        };
        $res = $kernel->index()->query("MATCH (n:page {Url: {url}}) RETURN n", ["url"=>$url]);
        if(count($res->results())==0) {
            return $kernel->founder()->post($url, $get_title($url));
        }
        return $kernel->gs()->node($res->results()[0]["udid"]);
    }
 
    public function isStarred(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'url' => 'required|url',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Url required.");
            return;
        }
          $page = $this->_fromUrlToNode($kernel, $data["url"]);
          $starrers = $page->getStarrers();
          $me= $session->get($request, "id");
          $this->succeed(
              $response, [
              "count"=>count($starrers), 
              "starred"=>is_null($me) ? false : $page->hasStarrer(ID::fromString($me))]
          );
    }

 
    public function edit(Request $request, Response $response, Session $session, Kernel $kernel) 
    {
     if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
     $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'id' => 'required',
            'content' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Comment ID and Content are required.");
            return;
        }
        $i = $kernel->gs()->node($id);
        $entity = $kernel->gs()->entity($data["id"]);
        if(!$entity instanceof Comment) {
            $this->fail($response, "Given ID is not a Comment.");
            return;
        }
        try {
        $i->edit($entity)->setContent($data["content"]);
        }
     catch(\Exception $e) {
        $this->fail($response, $e->getMessage());
            return;
     }
     $this->succeed($response);
    }

    public function comment(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'url' => 'required_without:id|url',
            'id' => 'required_without:url',
            'content' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "(Url or id) and content fields are required.");
            return;
        }
        $i = $kernel->gs()->node($id); 
        if(isset($data["url"])&&!empty($data["url"]))  {
            $page = $this->_fromUrlToNode($kernel, $data["url"]);
            
        }
        else {
            $page = $kernel->gs()->node($data["id"]);
            if(!$page instanceof Page && !$page instanceof Blog) {
                return $this->fail($response, "Can only comment on Blog or Web Page.");
            }
        }
        $comment = $i->comment(
            $page, 
            $data["content"], 
            (
                $id != $kernel->founder()->id()->toString()  // it's not the founder
                && 
                $kernel->graph()->getCommentsModerated() === true // it's not moderated
            )
        );
        $this->succeed($response, ["comment_id"=>$comment->id()->toString()]);
    }

    public function fetchComments(Request $request, Response $response, Kernel $kernel)
    {
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'url' => 'required_without:id|url',
            'id' => 'required_without:url',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Url or ID field is required.");
            return;
        }
        if(isset($data["url"])&&!empty($data["url"])) {
            $page = $this->_fromUrlToNode($kernel, $data["url"]);
        }
        else {
            $page = $kernel->gs()->node($data["id"]);
            if(!$page instanceof Page && !$page instanceof Blog) {
                return $this->fail($response, "Can only comment on Blog or Web Page.");
            }
        }
         $comments = array_map(
                function ($val) { 
                    $ret = [];
                    $attributes = $val->attributes()->toArray();
                    foreach($attributes as $k=>$v) {
                        $ret[\lcfirst($k)] = $v;
                    }
                    $ret['author'] = (string) $val->tail()->id();
                    
                    return [$val->id()->toString() => $ret];
                }, 
                $kernel->graph()->getCommentsModerated() === true ? 
                    array_filter($page->getComments(), function(Comment $comm) {
                        return $comm->getPending() !== true;
                    })
                    : $page->getComments()
         );
         $this->succeed(
             $response, [
                "comments"=>$comments
             ]
         );
    }

    public function delComment(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'comment_id' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Comment_id field is required.");
            return;
        }
        $i = $kernel->gs()->node($id);  
        if(!$i->hasComment(ID::fromString($data["comment_id"]))) {
            $this->fail($response, "Comment_id does not belong to you.");
            return;
        }
        $comment = $kernel->gs()->edge($data["comment_id"]);
        $comment->destroy();
        $this->succeed($response);
    }
 
    public function unstar(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'url' => 'required|url',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Url required.");
            return;
        }
        $i = $kernel->gs()->node($id);  
        $page = $this->_fromUrlToNode($kernel, $data["url"]);
        $stars = iterator_to_array($i->edges()->between($page->id(), Star::class));
        error_log("Total star count: ".count($stars));
        foreach($stars as $star) {
            error_log("Star ID: ".$star->id()->toString());
            $star->destroy();
        }
        $this->succeed($response);
    }
 
    /**
     * Fetch starred content
     *
     * @param Request  $request
     * @param Response $response
     * @param Session  $session
     * @param Kernel   $kernel
     * 
     * @return void
     */
    public function fetchStarredContent(Request $request, Response $response, Kernel $kernel)
    {
        $res = $kernel->index()->client()->run("MATCH ()-[e:star]-(n:page) WITH n.Url AS content, n.Title AS the_title, count(e) AS star_count RETURN the_title, content, star_count ORDER BY star_count");
        //$res = $kernel->index()->client()->run("MATCH ()-[e:star]-(n:page) WITH n.Url AS content, count(e) AS star_count RETURN content, star_count ORDER BY star_count");
        //eval(\Psy\sh());
        $array = $res->records();
        $ret = [];
        foreach($array as $a) {
            //$ret[$a->value("content")] = $a->value("star_count");
            $ret[$a->value("content")] = [
                "title" => $a->value("the_title"), 
                "star_count" => $a->value("star_count")
            ];
        }
        if(count($array)==0) {
            $this->fail($response, "No content starred yet");
        }
        $this->succeed($response, ["pages"=>$ret]);
    }

    public function fetchMyStars(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $res = $kernel->index()->client()->run(
            "MATCH (:user {udid: {me}})-[e:star]-(n:page) WITH n.Url AS content, n.Title AS the_title, count(e) AS star_count RETURN the_title, content, star_count ORDER BY star_count", 
            array("me"=>$id)
        );
        //$res = $kernel->index()->client()->run("MATCH ()-[e:star]-(n:page) WITH n.Url AS content, count(e) AS star_count RETURN content, star_count ORDER BY star_count");
        //eval(\Psy\sh());
        $array = $res->records();
        $ret = [];
        foreach($array as $a) {
            //$ret[$a->value("content")] = $a->value("star_count");
            $ret[$a->value("content")] = [
                "title" => $a->value("the_title"), 
                "star_count" => $a->value("star_count")
            ];
        }
        if(count($array)==0) {
            $this->fail($response, "No content starred yet");
        }
        $this->succeed($response, ["pages"=>$ret]);
    }

    public function addPrivateContent(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'data' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "Data field is required.");
            return;
        }
        $i = $kernel->gs()->node($id);  
        try {
            $private_content = $i->post("http://private/?".bin2hex(random_bytes(16)), $data["data"]);        ;
            return $this->succeed($response, ["id"=>(string) $private_content->id()]);
        }
        catch (\Exception $e) {
            return $this->fail($response, "Unknown error creating private content. Try again later.");
        }
    }

    public function editPrivateContent(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'id' => 'required',
            'data' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "ID and Data fields are required.");
            return;
        }
        $i = $kernel->gs()->node($id); 
        try {
            $private_content = $kernel->gs()->node($data["id"]);
            $i->edit($private_content)->setTitle($data["data"]);
            return $this->succeed($response);
        } 
        catch (\Exception $e) {
            return $this->fail($response, "Invalid ID");
        }
    }

    public function getPrivateContent(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'id' => 'required',
        ]);
        if($validation->fails()) {
            return $this->fail($response, "ID is required.");
        }
        try {
            $private_content = $kernel->gs()->node($data["id"]);
            if(!$private_content instanceof Page) {
                return $this->fail($response, "Invalid ID");
            }
            return $this->succeed($response, ["contents"=>$private_content->getTitle()]);
        }
        catch (\Exception $e) {
            return $this->fail($response, "Invalid ID");
        }
    }

    public function delPrivateContent(Request $request, Response $response, Session $session, Kernel $kernel)
    {
        if(is_null($id = $this->dependOnSession(...\func_get_args()))) {
            return;
        }
        $data = $request->getQueryParams();
        $validation = $this->validator->validate($data, [
            'id' => 'required',
        ]);
        if($validation->fails()) {
            $this->fail($response, "ID is required.");
            return;
        }
        try {
            $i = $kernel->gs()->node($id);
            $private_content = $kernel->gs()->node($data["id"]);
            if(!$private_content instanceof Page) {
                return $this->fail($response, "Invalid ID");
            }
            // check author
            if(
                !$i->id()->equals($kernel->founder()->id()) 
                &&
                !$private_content->edges()->in()->current()->tail()->node()->id()->equals($i->id())
            ) {
                return $this->fail($response, "No privileges to delete this content");
            }
            $private_content->destroy();
            return $this->succeed($response);
        }
        catch (\Exception $e) {
            return $this->fail($response, "Invalid ID");
        }
    }

}
